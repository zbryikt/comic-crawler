// Generated by LiveScript 1.2.0
var fs, system, config, comicName, newPage, getImages, getPages, getChapters;
fs = require('fs');
system = require('system');
if (system.args.length < 2) {
  console.log("usage: lsc crawler.ls [url-to-comic-index-page]");
  console.log("  e.g., lsc crawler.ls http://comic.sfacg.com/HTML/LNBFB/");
  phantom.exit(0);
}
config = {
  baseUrl: 'http://comic.sfacg.com/',
  bookUrl: system.args[1],
  chapters: [],
  chapter: {},
  idx: {
    c: 0,
    p: 1
  }
};
comicName = /\/([^\/]+)\/$/.exec(config.bookUrl);
if (!comicName) {
  console.log(config.bookUrl + ": url malformat. ");
  phantom.exit();
}
comicName = comicName[1];
newPage = function(){
  var x$, page;
  x$ = page = require('webpage').create();
  x$.settings.resourceTimeout = 3000;
  x$.onConsoleMessage = function(){};
  x$.onError = function(){};
  return x$;
};
getImages = function(config){
  var chapterUrl, url, page;
  chapterUrl = config.chapters[config.idx.c];
  url = config.baseUrl + "/" + config.chapters[config.idx.c] + "/?p=" + config.idx.p;
  console.log("parse url for image: " + url);
  page = newPage();
  return page.open(url, function(){
    var src, ref$;
    page.injectJs('jquery.min.js');
    src = page.evaluate(function(){
      return $('#curPic')[0].getAttribute('src');
    });
    console.log("image url: " + src);
    ((ref$ = config.chapter[config.idx.c]).img || (ref$.img = [])).push(src);
    config.idx.p++;
    if (config.idx.p > config.chapter[config.idx.c].pages) {
      config.idx.c++;
      config.idx.p = 1;
      if (config.idx.c >= config.chapters.length) {
        fs.write("data/" + comicName + "/config.json", JSON.stringify(config), 'w');
        return phantom.exit();
      } else {
        return setTimeout(function(){
          return getPages(config);
        }, 100);
      }
    } else {
      return setTimeout(function(){
        return getImages(config);
      }, 100);
    }
  });
};
getPages = function(config){
  var chapterUrl, ref$, key$, url, page;
  chapterUrl = config.chapters[config.idx.c];
  ((ref$ = config.chapter)[key$ = config.idx.c] || (ref$[key$] = {})).name = chapterUrl;
  url = config.baseUrl + "" + chapterUrl;
  console.log(">>> fetching chapter: " + chapterUrl + " (" + url + ")");
  page = newPage();
  return page.open(url, function(){
    var pages, ref$, key$;
    page.injectJs('jquery.min.js');
    pages = page.evaluate(function(){
      return $('#pageSel option').length;
    });
    console.log("chapter " + chapterUrl + " : total " + pages + " pages");
    ((ref$ = config.chapter)[key$ = config.idx.c] || (ref$[key$] = {})).pages = pages;
    config.idx.p = 1;
    setTimeout(function(){
      return page.close();
    }, 0);
    return setTimeout(function(){
      return getImages(config);
    }, 100);
  });
};
getChapters = function(config){
  var page;
  console.log("open " + config.bookUrl + " for chapter listing");
  page = newPage();
  return page.open(config.bookUrl, function(){
    var ref$, chapters, id;
    page.injectJs('jquery.min.js');
    ref$ = page.evaluate(function(){
      var list, ret, res$, i$, to$, i;
      list = $('.serialise_list li a');
      res$ = [];
      for (i$ = 0, to$ = list.length; i$ < to$; ++i$) {
        i = i$;
        res$.push(list[i].getAttribute('href'));
      }
      ret = res$;
      return [ret, comicCounterID];
    }), chapters = ref$[0], id = ref$[1];
    console.log(comicName + " comic id: " + id + ", estimate " + chapters.length + " chapters");
    ref$ = {
      chapters: chapters,
      id: id
    }, config.chapters = ref$.chapters, config.id = ref$.id;
    config.idx.c = 0;
    fs.write("data/" + comicName + "/config.json", JSON.stringify(config), 'w');
    phantom.exit();
    setTimeout(function(){
      return page.close();
    }, 0);
    return setTimeout(function(){
      return getPages(config);
    }, 100);
  });
};
if (!fs.exists('data')) {
  fs.mkdir('data');
}
if (!fs.exists("data/" + comicName)) {
  fs.mkdir("data/" + comicName);
}
if (!fs.exists("data/" + comicName + "/config.json")) {
  getChapters(config);
} else {
  phantom.exit();
}